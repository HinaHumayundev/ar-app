<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js ar - hit test with scoring</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, user-scalable=no"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			AR - Hit Test with Scoring<br />
			(Chrome Android 81+)
			<br />
			<button id="viewScores">View Top Scores</button>
			<div id="scoreDisplay">Score: 0</div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";
			import { ARButton } from "three/addons/webxr/ARButton.js";

			let container, camera, scene, renderer;
			let controller, reticle;
			let hitTestSource = null,
				hitTestSourceRequested = false;
			let score = 0;

			init();

			function init() {
				container = document.createElement("div");
				document.body.appendChild(container);

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera(
					70,
					window.innerWidth / window.innerHeight,
					0.01,
					20
				);

				const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
				light.position.set(0.5, 1, 0.25);
				scene.add(light);

				renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setAnimationLoop(animate);
				renderer.xr.enabled = true;
				container.appendChild(renderer.domElement);

				document.body.appendChild(
					ARButton.createButton(renderer, { requiredFeatures: ["hit-test"] })
				);

				const treeGeometry = createTreeGeometry();

				function onSelect() {
					if (reticle.visible) {
						const material = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
						const mesh = new THREE.Mesh(treeGeometry, material);
						reticle.matrix.decompose(
							mesh.position,
							mesh.quaternion,
							mesh.scale
						);
						scene.add(mesh);

						// Increase score and update display
						updateScore();
					}
				}

				controller = renderer.xr.getController(0);
				controller.addEventListener("select", onSelect);
				scene.add(controller);

				reticle = new THREE.Mesh(
					new THREE.CylinderGeometry(0.05, 0.05, 0.01, 32),
					new THREE.MeshBasicMaterial({ color: 0x00ff00 })
				);
				reticle.rotateX(-Math.PI / 2);
				reticle.matrixAutoUpdate = false;
				reticle.visible = false;
				scene.add(reticle);

				document
					.getElementById("viewScores")
					.addEventListener("click", showTopScores);

				window.addEventListener("resize", onWindowResize);
			}

			function createTreeGeometry() {
				const treeGroup = new THREE.Group();

				// Trunk
				const trunkGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 32);
				const trunkMaterial = new THREE.MeshBasicMaterial({ color: 0x8b4513 });
				const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
				trunk.position.y = 0.1;
				treeGroup.add(trunk);

				// Canopy
				const canopyGeometry = new THREE.SphereGeometry(0.15, 32, 32);
				const canopyMaterial = new THREE.MeshBasicMaterial({ color: 0x228b22 });
				const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
				canopy.position.y = 0.35;
				treeGroup.add(canopy);

				return treeGroup;
			}

			function updateScore() {
				score += 1;
				localStorage.setItem("score", score);
				document.getElementById("scoreDisplay").innerText = `Score: ${score}`;
			}

			function showTopScores() {
				const highScore = localStorage.getItem("score") || 0;
				alert(`Top Score: ${highScore}`);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate(timestamp, frame) {
				if (frame) {
					const referenceSpace = renderer.xr.getReferenceSpace();
					const session = renderer.xr.getSession();

					if (!hitTestSourceRequested) {
						session.requestReferenceSpace("viewer").then((refSpace) => {
							session
								.requestHitTestSource({ space: refSpace })
								.then((source) => {
									hitTestSource = source;
								});
						});

						session.addEventListener("end", () => {
							hitTestSourceRequested = false;
							hitTestSource = null;
						});

						hitTestSourceRequested = true;
					}

					if (hitTestSource) {
						const hitTestResults = frame.getHitTestResults(hitTestSource);
						if (hitTestResults.length) {
							const hit = hitTestResults[0];
							reticle.visible = true;
							reticle.matrix.fromArray(
								hit.getPose(referenceSpace).transform.matrix
							);
						} else {
							reticle.visible = false;
						}
					}
				}

				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
